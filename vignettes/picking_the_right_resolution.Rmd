---
title: "Picking the right resolution"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{picking_the_right_resolution}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r setup, eval=FALSE}
library(igraph)
library(schex)
library(TENxPBMCData)
library(scater)
library(scran)
library(ggrepel)
```

The resolution of the schex plots is determined by the number of bins
the range of the first component of the chosen dimension reduction is
partitioned into. Different values of this parameter can result in
different looking plots, especially for small datasets. In order to
investigate this effect further, schex offers a interactive plot. I will
demonstrate the use of this plot using the Peripheral Blood Mononuclear
Cells (PBMC) freely available from 10x Genomics. I will do minimal
processing.

## Setup single cell data

The data is handily available in the [`TENxPBMCData`
package](http://bioconductor.org/packages/release/data/experiment/html/TENxPBMCData.html).

```{r load, eval=FALSE}
tenx_pbmc3k <- TENxPBMCData(dataset = "pbmc3k")

rownames(tenx_pbmc3k) <- uniquifyFeatureNames(rowData(tenx_pbmc3k)$ENSEMBL_ID, 
    rowData(tenx_pbmc3k)$Symbol_TENx)
```

### Filtering

I filter cells with high mitochondrial content as well as cells with low
library size or feature count.

```{r filter-cells, eval=FALSE}
rowData(tenx_pbmc3k)$Mito <- grepl("^MT-", rownames(tenx_pbmc3k))
colData(tenx_pbmc3k) <- cbind(colData(tenx_pbmc3k), 
    perCellQCMetrics(tenx_pbmc3k, 
        subsets=list(Mt=rowData(tenx_pbmc3k)$Mito)))
rowData(tenx_pbmc3k) <- cbind(rowData(tenx_pbmc3k), 
    perFeatureQCMetrics(tenx_pbmc3k))

tenx_pbmc3k <- tenx_pbmc3k[, !colData(tenx_pbmc3k)$subsets_Mt_percent > 50]

libsize_drop <- isOutlier(tenx_pbmc3k$total,
      nmads = 3,type = "lower", log = TRUE)
feature_drop <- isOutlier(tenx_pbmc3k$detected,
    nmads = 3, type = "lower", log = TRUE)

tenx_pbmc3k <- tenx_pbmc3k[, !(libsize_drop | feature_drop)]
```

I filter any genes that have 0 count for all cells.

```{r filter-genes, eval=FALSE}
rm_ind <- calculateAverage(tenx_pbmc3k)<0
tenx_pbmc3k <- tenx_pbmc3k[!rm_ind,]
```

### Normalization

I normalize the data by using a simple library size normalization.

```{r norm, message=FALSE, warning=FALSE, eval=FALSE}
tenx_pbmc3k <- scater::logNormCounts(tenx_pbmc3k)
```

### Dimension reduction

I use both Principal Components Analysis (PCA) and Uniform Manifold
Approximation and Projection (UMAP) in order to obtain reduced dimension
representations of the data. Since there is a random component in the
UMAP, I will also set a seed.

```{r dim-red, message=FALSE, warning=FALSE, eval=FALSE}
tenx_pbmc3k <- runPCA(tenx_pbmc3k)
set.seed(10)
tenx_pbmc3k <- runUMAP(tenx_pbmc3k, dimred = "PCA", spread = 1, 
    min_dist = 0.4)
```

### Clustering

I will cluster the data on the PCA representation using Louvain
clustering.

```{r cluster, eval=FALSE}
snn_gr <- buildSNNGraph(tenx_pbmc3k, use.dimred = "PCA", k = 50)
clusters <- cluster_louvain(snn_gr)
tenx_pbmc3k$cluster <- factor(clusters$membership)
```
